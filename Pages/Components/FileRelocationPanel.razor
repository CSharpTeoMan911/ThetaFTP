@using ThetaFTP.Shared.Formatters;
@using ThetaFTP.Shared.Models;
@using ThetaFTP.Shared.Classes;
@using System.Text;
@inject IJSRuntime JS;
@inject IHttpClientFactory httpFactory;
@inject NavigationManager NavigationManager;

@using Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage;
@inject ProtectedLocalStorage protectedLocalStorage;


@if (ShowNotification == true)
{
    <Notifications notificationType=@notificationType NotificationMessage=@notificationMessage closeNotification=@CloseNotification style="z-index:10" />
}

<FocusPanel style="z-index:5;">
    <Component>
        <div class="jumbotron" style="padding:5px; display:flex; flex-direction:column; width:fit-content; align-self:center; margin-top: 300px;">
            <div style="display:flex; flex-direction:row-reverse">
                <button class="close_button">
                    <img src="./images/close.webp" style="width:20px;" @onclick="@Close"/>
                </button>
            </div>

            <div style="display:flex; flex-direction:column">
                <div style="display: flex; flex-direction:row">
                    @if(ShowBackButton == true){
                        <div style="display: flex; align-self:center; align-content:center">
                            <button style="display: flex; align-self:center; align-content:center; border-color: transparent" @onclick=Back>
                                <img src="./images/left-arrow.webp" style="height: 15px; align-self:center" />
                            </button>
                            <p style="align-self:center; padding: 0px 0px 0px 0px; margin: 0px 0px 0px 20px">
                                @last_dir
                            </p>
                        </div>
                    }
                </div>
                <div style="display:flex; flex-direction:column; overflow-y:auto; width:calc(220px + 20vw); height:300px;">
                    @for (int i = 0; i < directories?.Count; i++)
                    {
                        bool show = false;
                        DirectoryItem? item = directories?.ElementAt(i);

                        if (selected_item?.name != item?.name)
                            show = true;
                        else
                            if(Path != SrcPath)
                            show = true;

                        if (show == true)
                        {
                            <div style="display: flex; flex-direction: row; padding: 20px;">
                                <div style="display: flex; flex-direction: row; width: 50%">
                                    <img src="./images/folder.webp" style="width:40px; height:40px" />
                                    <input class="display" value=" @item?.name" readonly="readonly" />
                                </div>
                                <div style="display:flex; flex-direction:row-reverse; width: 50%">
                                    @if (item.name != "/")
                                    {
                                        <button @onclick=@(()=>Open(item)) class="file_relocation" style="margin-left:30px; background-color: black; color: white; border-color: black; cursor: pointer">
                                            Open
                                        </button>
                                    }
                                            <button @onclick=@(()=>Select(item)) class="file_relocation" style="cursor: pointer">
                                        Select
                                    </button>
                                </div>
                            </div>
                        }
                    }
                </div>
            </div>
        </div>
    </Component>
</FocusPanel>

@code {
    private bool ShowBackButton{ get; set; }
    private string? last_dir { get; set; }

    private List<DirectoryItem>? directories { get; set; }

    [Parameter] public string? Path { get; set; }
    public string? Current_Path { get; set; }
    private string? SrcPath { get; set; }

    public delegate void ClosePanel();
    [Parameter] public ClosePanel? closePanel { get; set; }

    [Parameter] public DirectoryItem? selected_item {get;set;}

    private bool ShowNotification { get; set; }
    private bool NavigateToLogIn { get; set; }

    private Notifications.NotificationType notificationType { get; set; }
    private string? notificationMessage { get; set; }

    private System.Timers.Timer? timer { get; set; }
    private DateTime start { get; set; }

    private bool refresh { get; set; }

    private void Close() => closePanel?.Invoke();

    private bool Loaded { get; set; }
    private bool Init { get; set; }


    protected override void OnAfterRender(bool firstRender)
    {
        base.OnAfterRender(firstRender);

        if (firstRender == true)
        {
            timer?.Dispose();
            SrcPath = Path;
            Current_Path = Path;
            Loaded = true;
            StateHasChanged();
        }

        if(Loaded == true && Init == false)
        {
            Init = true;
            GetDirectories();
        }
    }

    private async void GetDirectories()
    {
        if (Loaded == true)
        {
            Tuple<bool, string?> last_dir_ = await FileSystemFormatter.GetLastDir(Current_Path);

            ShowBackButton = last_dir_.Item1;
            last_dir = last_dir_.Item2;

            string? log_in_session_key = null;

            if (Shared.configurations?.use_secure_local_storage == true)
            {
                ProtectedBrowserStorageResult<string> log_in_session_key_result = await protectedLocalStorage.GetAsync<string>("AuthCache");
                log_in_session_key = log_in_session_key_result.Value;
            }
            else
            {
                IJSObjectReference module = await JS.InvokeAsync<IJSObjectReference>("import", "./js/functions.js");
                log_in_session_key = await module.InvokeAsync<string>("Get_Cache", "auth", "AuthCache");
                await module.DisposeAsync();
            }

            Metadata metadata = new Metadata()
                {
                    path = Current_Path,
                    key = log_in_session_key
                };

            string? url = new StringBuilder().Append("/directories/get-directories?").Append(await QueryParsing.QueryParser(metadata)).ToString();

            HttpClient client = httpFactory.CreateClient(Shared.HttpClientConfig);
            client.BaseAddress = new Uri(NavigationManager.BaseUri);

            HttpResponseMessage httpResponse = await client.GetAsync(url);
            string result = await httpResponse.Content.ReadAsStringAsync();

            directories = await JsonFormatter.JsonDeserialiser<List<DirectoryItem>?>(result);

            if (Current_Path == "/")
                directories.Add(new DirectoryItem()
                {
                    isDirectory = true,
                    name = Current_Path
                });
            StateHasChanged();
        }
    }


    private void Back()
    {
        directories?.Clear();
        Current_Path = FileSystemFormatter.NavigateBackward(Current_Path);
        GetDirectories();
    }

    private void Open(DirectoryItem? item)
    {
        directories?.Clear();
        Current_Path = FileSystemFormatter.NavigateForward(Current_Path, item?.name);
        GetDirectories();
    }

    private async void Select(DirectoryItem? item)
    {
        if(Loaded)
        {
            string? log_in_session_key = null;

            if (Shared.configurations?.use_secure_local_storage == true)
            {
                ProtectedBrowserStorageResult<string> log_in_session_key_result = await protectedLocalStorage.GetAsync<string>("AuthCache");
                log_in_session_key = log_in_session_key_result.Value;
            }
            else
            {
                IJSObjectReference module = await JS.InvokeAsync<IJSObjectReference>("import", "./js/functions.js");
                log_in_session_key = await module.InvokeAsync<string>("Get_Cache", "auth", "AuthCache");
                await module.DisposeAsync();
            }

            string? selected_path = Current_Path?[Current_Path.Length - 1] == '/' ? new StringBuilder(Current_Path).Append(item?.name).ToString() : new StringBuilder(Current_Path).Append('/').Append(item?.name).ToString(); ;
            StringBuilder? request_url = new StringBuilder();

            if (selected_item?.isDirectory == false)
            {
                FileOperationMetadata fileOperationMetadata = new FileOperationMetadata()
                    {
                        key = log_in_session_key,
                        file_name = selected_item?.name,
                        path = Path,
                        new_path = selected_path
                    };
                request_url.Append("/files/relocate?").Append(await QueryParsing.QueryParser(fileOperationMetadata));
            }
            else
            {
                DirectoryOperationMetadata directoryOperationMetadata = new DirectoryOperationMetadata()
                    {
                        key = log_in_session_key,
                        directory_name = selected_item?.name,
                        path = Path,
                        new_path = selected_path
                    };
                request_url.Append("/directories/relocate?").Append(await QueryParsing.QueryParser(directoryOperationMetadata));
            }

            HttpClient client = httpFactory.CreateClient(Shared.HttpClientConfig);
            client.BaseAddress = new Uri(NavigationManager.BaseUri);
            HttpResponseMessage responseMessage = await client.PutAsync(request_url.ToString(), null);

            string response = await responseMessage.Content.ReadAsStringAsync();

            notificationMessage = response;

            if (response.Contains("Internal server error") == true)
            {
                notificationType = Notifications.NotificationType.Error;
            }
            else if (response.Contains("Invalid log in session key") == true)
            {
                notificationType = Notifications.NotificationType.Error;
                NavigateToLogIn = true;
            }
            else if (response.Contains("Log in session key expired") == true)
            {
                notificationType = Notifications.NotificationType.Error;
                NavigateToLogIn = true;
            }
            else if (response.Contains("Log in session not approved") == true)
            {
                notificationType = Notifications.NotificationType.Error;
                NavigateToLogIn = true;
            }
            else if (response.Contains("Invalid file name") == true)
            {
                notificationType = Notifications.NotificationType.Error;
            }
            else if (response.Contains("Invalid path") == true)
            {
                notificationType = Notifications.NotificationType.Error;
            }
            else if (response.Contains("File already exist") == true)
            {
                notificationType = Notifications.NotificationType.Error;
            }
            else if (response.Contains("Invalid file name. Use only numbers, letters, '-', '/', '_', ' ', and '.'") == true)
            {
                notificationType = Notifications.NotificationType.Error;
            }
            else if (response.Contains("File relocation successful") == true)
            {
                notificationType = Notifications.NotificationType.Information;
                refresh = true;
            }
            else if (response.Contains("Directory relocation successful") == true)
            {
                notificationType = Notifications.NotificationType.Information;
                refresh = true;
            }
            else
            {
                notificationMessage = "Internal server error";
                notificationType = Notifications.NotificationType.Error;
            }

            start = DateTime.Now;

            timer = new System.Timers.Timer();
            timer.Interval = 100;
            timer.Elapsed += Elapsed;
            timer.Start();

            ShowNotification = true;
            StateHasChanged();
        }
    }

    private void Elapsed(object? obj, System.Timers.ElapsedEventArgs args)
    {
        if ((DateTime.Now - start).TotalSeconds >= 7)
        {
            ((Timer?)obj)?.Dispose();
            CloseNotification();
        }
    }

    private void CloseNotification()
    {
        if (NavigateToLogIn == true)
        {
            NavigationManager.NavigateTo("/log-in", true);
        }
        else if (refresh == true)
        {
            NavigationManager.Refresh(true);
        }

        ShowNotification = false;
        StateHasChanged();
    }
}
